# Dev-Interview 的解析及思路复盘
> [题干](https://github.com/PatRuan/Dev-Interview)

## 代码写出算法
主程序：Interview.java

思考过程：
一开始以数组占数组总和的百分比去算中奖概率，eg：元素/元素总和，然后想到除法运算没加法快，就改成把每个元素累加的值依次放入新的数组。
按照差值所占的区间当概率用，还刚好省去数组排序的操作。

### 随机数的和中奖概率的思路
按照上面的分析，存在一个问题，积分和中奖概率的函数曲线是直线（导数为0）。
如果我们进一步完善中奖规则的话，其实还要考虑，随着积分的增加，中奖的概率是越来越大（中奖概率的幅度也会越来越大）
```
中奖概率
^
|              
|             _______
|            /
|           /
|          |
|         /
|        /
|     __/
| __--
|________________________________> 积分
```
随着积分的增加，中奖概率的函数是由缓到陡的改变。

这里的概率就不是代码中差值区间了，而是差值区间的 （1+x）^2

如果我们用纯元素/元素总和的说法就是
假如数组 "5,4,3,13,4,34,34,45,2,10" ，总和是：154。
第一个元素的“5”占比是5/154*100% = 32.46%。这是积分和概率成正比的情况。
如果需要积分越多概率越大不成正比应该再乘一个次方。（如上图的前半部分到中部，斜率由小变大那段）
```
32.46% * [（1+x）^y]
```

积分后半段概率斜率变小的那块，可以设定一个阈值，积分到达一定什么程度的时候，在概率上乘以一个衰变系数，比如
```
32.46% * [（1+x）^y] * 0.8 (这里的衰变系数0.8，我就随便写了，正常也是需要活动者预设的，包括1+x，y 这块也是)
```

## 分析其时间复杂度
时间复杂度这块，因为没有用排序，前后使用的有 for（ **复杂度 O(n)** ） 和 二分法（ **复杂度 O(logn)** ）

总结：复杂度是 O(logn)

## 为其编写尽量多 unit test
文件为：Test.java 有四个单元测试。以下是单元测试控制台日志：
```
initArray: 5,4,3,13,4,34,34,45,2,10
--- 数组初始化完成 ---
totalArray: 5,9,12,25,29,63,97,142,144,154
总和为： 154
---生成的随机数是：---  92
---随机数坐落在差值数组的下标（同时也是中奖用户的ID）：--- 6
---初始数组对应的数值是：---34
---中奖用户的ID：---6
interview： 6


initArray: 5,4,3,13,4,34,34,45,2,10
--- 数组初始化完成 ---
totalArray: 5,9,12,25,29,63,97,142,144,154
总和为： 154
---生成的随机数是：---  97
---随机数坐落在差值数组的下标（同时也是中奖用户的ID）：--- 6
---初始数组对应的数值是：---34
---中奖用户的ID：---6
interview： 6


initArray: 5,4,3,13,4,35,34,45,2,1
--- 数组初始化完成 ---
totalArray: 5,9,12,25,29,64,98,143,145,146
总和为： 146
---生成的随机数是：---  28
---随机数坐落在差值数组的下标（同时也是中奖用户的ID）：--- 4
---初始数组对应的数值是：---4
---中奖用户的ID：---4
interview： 4


initArray: 5,4,3,13,4,35,34,45,2,1
--- 数组初始化完成 ---
totalArray: 5,9,12,25,29,64,98,143,145,146
总和为： 146
---生成的随机数是：---  86
---随机数坐落在差值数组的下标（同时也是中奖用户的ID）：--- 6
---初始数组对应的数值是：---34
---中奖用户的ID：---6
interview： 6



Process finished with exit code 0

```

---
最后用时：
- 思考：20分钟
- 编码：10分钟
- 调试+单元：一边加注解一边加控制台的友好性，30分钟
- 写readme：20分钟
